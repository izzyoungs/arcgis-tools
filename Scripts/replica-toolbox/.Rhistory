sql <- glue_sql("
SELECT pop.person_id, activity_id, distance_miles, mode, travel_purpose, pop.commute_mode, pop.household_size, pop.vehicles, pop.age_group, pop.sex, pop.race, pop.ethnicity, pop.employment, pop.education, start_lat, start_lng, end_lat, end_lng, pop.lat as home_lat, pop.lng as home_lng
FROM `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_{day_sql}_trip` as trip
LEFT JOIN `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_population` as pop
ON trip.person_id = pop.person_id
{where_destinations}
{both_and} {where_home_locations}",
.con = DBI::ANSI()
)
print("Executing SQL query...")
print(sql)
# If destinations path is not empty, load the destinations boundary
if (length(destinations) > 0) {
print("Loading boundary for destinations")
destinations_sf <- arc.open(destinations) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
summarize() |>
suppressMessages()
destinations_wkt <- st_as_text(destinations_sf$geom) |> glue_sql()
# if destinations_wkt is over 1000 characters, get the bounding box instead
if (nchar(destinations_wkt) > 1000) {
bbox_destinations <- st_bbox(destinations_sf)
bbox_destinations_coords <- matrix(
c(
bbox_destinations["xmin"], bbox_destinations["ymin"], # Bottom-left
bbox_destinations["xmax"], bbox_destinations["ymin"], # Bottom-right
bbox_destinations["xmax"], bbox_destinations["ymax"], # Top-right
bbox_destinations["xmin"], bbox_destinations["ymax"], # Top-left
bbox_destinations["xmin"], bbox_destinations["ymin"] # Close the polygon
),
ncol = 2, byrow = TRUE
)
bbox_destinations_polygon <- st_polygon(list(bbox_destinations_coords))
destinations_wkt <- st_as_text(bbox_destinations_polygon) |>
glue_sql()
}
where_destinations <- glue_sql("WHERE ST_WITHIN(ST_GEOGPOINT(end_lng, end_lat), ST_GEOGFROMTEXT('{destinations_wkt}'))",
.con = DBI::ANSI()
)
# If the home locations path is not empty, load the home locations boundary
} else {
print("No destinations provided. Using home locations to determine trips.")
where_destinations <- glue_sql("WHERE", .con = DBI::ANSI())
}
if (length(destinations) > 0 & length(home_locations) > 0) {
both_and <- glue_sql("AND", .con = DBI::ANSI())
} else {
both_and <- glue_sql("", .con = DBI::ANSI())
}
if (length(home_locations) > 0) {
print("Loading boundary for home locations")
home_locations_sf <- arc.open(home_locations) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
summarize() |>
suppressMessages()
home_locations_wkt <- st_as_text(home_locations_sf$geom) |> glue_sql()
# if home_locations_wkt is over 1000 characters, get the bounding box instead
if (nchar(home_locations_wkt) > 1000) {
bbox_home_locations <- st_bbox(home_locations_sf)
bbox_home_locations_coords <- matrix(
c(
bbox_home_locations["xmin"], bbox_home_locations["ymin"], # Bottom-left
bbox_home_locations["xmax"], bbox_home_locations["ymin"], # Bottom-right
bbox_home_locations["xmax"], bbox_home_locations["ymax"], # Top-right
bbox_home_locations["xmin"], bbox_home_locations["ymax"], # Top-left
bbox_home_locations["xmin"], bbox_home_locations["ymin"] # Close the polygon
),
ncol = 2, byrow = TRUE
)
bbox_home_locations_polygon <- st_polygon(list(bbox_home_locations_coords))
home_locations_wkt <- st_as_text(bbox_home_locations_polygon) |>
glue_sql()
}
where_home_locations <- glue_sql("ST_WITHIN(ST_GEOGPOINT(lng, lat), ST_GEOGFROMTEXT('{home_locations_wkt}'))",
.con = DBI::ANSI()
)
} else if (length(destinations) == 0 & length(home_locations) == 0) {
print("No destinations or home location boundaries provided. Please provide a way to return trip table.")
stop()
} else {
print("No home locations provided. Using destinations only to determine trips.")
where_home_locations <- glue_sql("", .con = DBI::ANSI())
}
sql <- glue_sql("
SELECT pop.person_id, activity_id, distance_miles, mode, travel_purpose, pop.commute_mode, pop.household_size, pop.vehicles, pop.age_group, pop.sex, pop.race, pop.ethnicity, pop.employment, pop.education, start_lat, start_lng, end_lat, end_lng, pop.lat as home_lat, pop.lng as home_lng
FROM `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_{day_sql}_trip` as trip
LEFT JOIN `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_population` as pop
ON trip.person_id = pop.person_id
{where_destinations}
{both_and} {where_home_locations}",
.con = DBI::ANSI()
)
print("Executing SQL query...")
print(sql)
length(destinations)
length(home_locations)
home_locations_tag <- isna()
home_locations_tag <- NULL
home_locations <- NULL
home_locations_tag <- NULL
home_locations_tag_field <- NULL
if (length(destinations) > 0) {
print("Loading boundary for destinations")
destinations_sf <- arc.open(destinations) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
summarize() |>
suppressMessages()
destinations_wkt <- st_as_text(destinations_sf$geom) |> glue_sql()
# if destinations_wkt is over 1000 characters, get the bounding box instead
if (nchar(destinations_wkt) > 1000) {
bbox_destinations <- st_bbox(destinations_sf)
bbox_destinations_coords <- matrix(
c(
bbox_destinations["xmin"], bbox_destinations["ymin"], # Bottom-left
bbox_destinations["xmax"], bbox_destinations["ymin"], # Bottom-right
bbox_destinations["xmax"], bbox_destinations["ymax"], # Top-right
bbox_destinations["xmin"], bbox_destinations["ymax"], # Top-left
bbox_destinations["xmin"], bbox_destinations["ymin"] # Close the polygon
),
ncol = 2, byrow = TRUE
)
bbox_destinations_polygon <- st_polygon(list(bbox_destinations_coords))
destinations_wkt <- st_as_text(bbox_destinations_polygon) |>
glue_sql()
}
where_destinations <- glue_sql("WHERE ST_WITHIN(ST_GEOGPOINT(end_lng, end_lat), ST_GEOGFROMTEXT('{destinations_wkt}'))",
.con = DBI::ANSI()
)
# If the home locations path is not empty, load the home locations boundary
} else {
print("No destinations provided. Using home locations to determine trips.")
where_destinations <- glue_sql("WHERE", .con = DBI::ANSI())
}
if (length(destinations) > 0 & length(home_locations) > 0) {
both_and <- glue_sql("AND", .con = DBI::ANSI())
} else {
both_and <- glue_sql("", .con = DBI::ANSI())
}
if (length(home_locations) > 0) {
print("Loading boundary for home locations")
home_locations_sf <- arc.open(home_locations) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
summarize() |>
suppressMessages()
home_locations_wkt <- st_as_text(home_locations_sf$geom) |> glue_sql()
# if home_locations_wkt is over 1000 characters, get the bounding box instead
if (nchar(home_locations_wkt) > 1000) {
bbox_home_locations <- st_bbox(home_locations_sf)
bbox_home_locations_coords <- matrix(
c(
bbox_home_locations["xmin"], bbox_home_locations["ymin"], # Bottom-left
bbox_home_locations["xmax"], bbox_home_locations["ymin"], # Bottom-right
bbox_home_locations["xmax"], bbox_home_locations["ymax"], # Top-right
bbox_home_locations["xmin"], bbox_home_locations["ymax"], # Top-left
bbox_home_locations["xmin"], bbox_home_locations["ymin"] # Close the polygon
),
ncol = 2, byrow = TRUE
)
bbox_home_locations_polygon <- st_polygon(list(bbox_home_locations_coords))
home_locations_wkt <- st_as_text(bbox_home_locations_polygon) |>
glue_sql()
}
where_home_locations <- glue_sql("ST_WITHIN(ST_GEOGPOINT(lng, lat), ST_GEOGFROMTEXT('{home_locations_wkt}'))",
.con = DBI::ANSI()
)
} else if (length(destinations) == 0 & length(home_locations) == 0) {
print("No destinations or home location boundaries provided. Please provide a way to return trip table.")
stop()
} else {
print("No home locations provided. Using destinations only to determine trips.")
where_home_locations <- glue_sql("", .con = DBI::ANSI())
}
# Get Home Location Tags --------------------------------------------------
if (length(home_locations_tag) > 0 & length(home_locations_tag_field) > 0) {
home_locations_tag_sf <- arc.open(home_locations_tag) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
select(any_of(home_locations_tag_field)) |>
suppressMessages()
print(paste0("Will assign home locations the following tag: ", home_locations_tag_field))
} else {
print("No home location tags provided. Will not append a home location flag to table.")
}
if (length(destinations) == 0) {
sf_megaregions <= home_locations_sf
} else {
sf_megaregions <- destinations_sf
}
megaregion <- left_join(tigris::states(cb = TRUE, year = 2023, progress_bar = FALSE), megaregions) |>
st_intersection(sf_megaregions) |>
st_drop_geometry() |>
slice(1L) |>
pull(Megaregion) |>
glue_sql() |>
suppressMessages() |>
suppressWarnings()
# Get SQL arguments for query ---------------------------------------------
# Construct the SQL query
print(paste0("Constructing SQL query for ", megaregion, ", ", year, " ", quarter, " ", day, "..."))
year_sql <- glue_sql(year)
quarter_sql <- glue_sql(quarter)
day_sql <- glue_sql(day)
sql <- glue_sql("
SELECT pop.person_id, activity_id, distance_miles, mode, travel_purpose, pop.commute_mode, pop.household_size, pop.vehicles, pop.age_group, pop.sex, pop.race, pop.ethnicity, pop.employment, pop.education, start_lat, start_lng, end_lat, end_lng, pop.lat as home_lat, pop.lng as home_lng
FROM `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_{day_sql}_trip` as trip
LEFT JOIN `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_population` as pop
ON trip.person_id = pop.person_id
{where_destinations}
{both_and} {where_home_locations}",
.con = DBI::ANSI()
)
print("Executing SQL query...")
print(sql)
tb <- bq_project_query("replica-customer", sql) |>
suppressMessages() |>
suppressWarnings()
tb_return <- bq_table_download(tb, page_size = 10000) |>
suppressMessages() |>
suppressWarnings()
tb
tb_return <- bq_table_download(tb) |>
suppressMessages() |>
suppressWarnings()
polygon <- "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))"
# Convert WKT to sf
polygon_sf <- st_as_sfc(polygon, crs = 4326)
polygon_sf
mapview::mapview(polygon_sf)
polygon <- c("geometry" = "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))")
polygon
polygon_sf <- st_as_sfc(polygon, crs = 4326)
polygon_sf
mapview::mapview(polygon_sf)
polygon <- c("geometry" = "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))", "Test" = 1)
polygon
polygon_sf <- st_as_sfc(polygon, crs = 4326)
polygon <- "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))"
polygon_sf <- st_as_sfc(polygon, crs = 4326)
mapview::mapview(polygon_sf)
coords <- matrix(c(
-118.9447, 32.79959,
-117.6464, 32.79959,
-117.6464, 34.8233,
-118.9447, 34.8233,
-118.9447, 32.79959
), ncol = 2, byrow = TRUE)
polygon_sf <- st_sfc(st_polygon(list(coords)), crs = 4326)
mapview::mapview(polygon_sf)
polygon_sf <- st_as_sfc(polygon, crs = 4326) |>
st_make_valid()
mapview::mapview(polygon_sf)
polygon <- "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))"
polygon_sf <- st_as_sfc(polygon, crs = 4326) |>
st_make_valid()
mapview::mapview(polygon_sf)
mapview::mapview(
poly,
col = "red",               # outline color
lwd = 3,                   # thicker outline
alpha.regions = 0.25,      # visible fill
layer.name = "My polygon"
)
mapview::mapview(
polygon_sf,
col = "red",               # outline color
lwd = 3,                   # thicker outline
alpha.regions = 0.25,      # visible fill
layer.name = "My polygon"
)
mapview::mapview(
polygon_sf,
col = "red",               # outline color
lwd = 3,                   # thicker outline
alpha.regions = 0.25,      # visible fill
layer.name = "My polygon"
)
mapview::mapview(
polygon_sf,
col = "red",               # outline color
lwd = 3,                   # thicker outline
alpha.regions = 0.25,      # visible fill
)
mapview::mapview(
polygon_sf,
col = "red",               # outline color
lwd = 3,                   # thicker outline
)
mapview::mapview(
polygon_sf,
col = "red",               # outline color
lwd = 3,                   # thicker outline
)
mapview::mapview(
polygon_sf,
lwd = 3,                   # thicker outline
)
mapview::mapview(
polygon_sf
)
st_crs(polygon_sf)           # should be EPSG:4326
st_geometry_type(polygon_sf) # should be POLYGON
st_is_valid(polygon_sf)      # should be TRUE
st_is_empty(polygon_sf)      # should be FALSE
st_bbox(polygon_sf)          # should be around x:-119..-117.6, y:32.8..34.8
st_area(st_transform(poly, 3857))  # area in m^2 just to confirm it's not degenerate
st_area(polygon_sf)  # area in m^2 just to confirm it's not degenerate
st_geometry_type(polygon_sf) # should be POLYGON
bb   <- st_bbox(c(xmin = -118.9447, ymin = 32.79959, xmax = -117.6464, ymax = 34.8233), crs = st_crs(4326))
poly2 <- st_as_sfc(bb)  # rectangle from bbox
mapview(poly2, col = "blue", lwd = 4, alpha.regions = 0.3, layer.name = "BBox polygon")
mapview::mapview(poly2, col = "blue", lwd = 4, alpha.regions = 0.3, layer.name = "BBox polygon")
mapview::mapview(poly2)
library(leaflet)
leaflet() |>
addTiles() |>
addPolygons(data = st_transform(polygon_sf, 4326),
weight = 4, color = "red", fillOpacity = 0.3)
polygon <- "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))"
polygon_sf <- st_as_sfc(polygon, crs = 4326) |>
st_make_valid()
leaflet() |>
addTiles() |>
addPolygons(data = st_transform(polygon_sf, 4326),
weight = 4, color = "red", fillOpacity = 0.3)
polygon <- "POLYGON ((-118.9447 32.79959, -117.6464 32.79959, -117.6464 34.8233, -118.9447 34.8233, -118.9447 32.79959))"
polygon_sf <- st_as_sfc(polygon, crs = 4326) |>
st_make_valid()
leaflet() |>
addTiles() |>
addPolygons(data = polygon_sf,
weight = 4, color = "red", fillOpacity = 0.3)
leaflet() |>
addTiles() |>
addPolygons(data = destinations_sf,
weight = 4, color = "red", fillOpacity = 0.3)
library(sf)
library(tidyverse)
library(bigrquery)
library(glue)
library(arcgisbinding)
arc.check_product()
destinations <- "N:/Shared/PROJECTS/2025/2025.070 Claremont, CA ATP/GIS/Process/2025.070_Claremont_ATP/Task_Working_Data.gdb/Boundaries/City_SOI"
home_locations <- NULL
home_locations_tag <- NULL
home_locations_tag_field <- NULL
email <- "izzyyoungs@altago.com"
year <- 2024
quarter <- "Q4"
day <- "thursday"
output_path <- "N:/Shared/PROJECTS/2025/2025.070 Claremont, CA ATP/GIS/Process/2025.070_Claremont_ATP/Task_Working_Data.gdb/Replica_Claremont_Table"
# Authenticate with BigQuery
print("Authenticating with BigQuery")
bq_auth(email = email)
# If destinations path is not empty, load the destinations boundary
if (length(destinations) > 0) {
print("Loading boundary for destinations")
destinations_sf <- arc.open(destinations) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
summarize() |>
suppressMessages()
destinations_wkt <- st_as_text(destinations_sf$geom) |> glue_sql()
# if destinations_wkt is over 1000 characters, get the bounding box instead
if (nchar(destinations_wkt) > 1000) {
bbox_destinations <- st_bbox(destinations_sf)
bbox_destinations_coords <- matrix(
c(
bbox_destinations["xmin"], bbox_destinations["ymin"], # Bottom-left
bbox_destinations["xmax"], bbox_destinations["ymin"], # Bottom-right
bbox_destinations["xmax"], bbox_destinations["ymax"], # Top-right
bbox_destinations["xmin"], bbox_destinations["ymax"], # Top-left
bbox_destinations["xmin"], bbox_destinations["ymin"] # Close the polygon
),
ncol = 2, byrow = TRUE
)
bbox_destinations_polygon <- st_polygon(list(bbox_destinations_coords))
destinations_wkt <- st_as_text(bbox_destinations_polygon) |>
glue_sql()
}
where_destinations <- glue_sql("WHERE ST_WITHIN(ST_GEOGPOINT(end_lng, end_lat), ST_GEOGFROMTEXT('{destinations_wkt}'))",
.con = DBI::ANSI()
)
# If the home locations path is not empty, load the home locations boundary
} else {
print("No destinations provided. Using home locations to determine trips.")
where_destinations <- glue_sql("WHERE", .con = DBI::ANSI())
}
if (length(destinations) > 0 & length(home_locations) > 0) {
both_and <- glue_sql("AND", .con = DBI::ANSI())
} else {
both_and <- glue_sql("", .con = DBI::ANSI())
}
if (length(home_locations) > 0) {
print("Loading boundary for home locations")
home_locations_sf <- arc.open(home_locations) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
summarize() |>
suppressMessages()
home_locations_wkt <- st_as_text(home_locations_sf$geom) |> glue_sql()
# if home_locations_wkt is over 1000 characters, get the bounding box instead
if (nchar(home_locations_wkt) > 1000) {
bbox_home_locations <- st_bbox(home_locations_sf)
bbox_home_locations_coords <- matrix(
c(
bbox_home_locations["xmin"], bbox_home_locations["ymin"], # Bottom-left
bbox_home_locations["xmax"], bbox_home_locations["ymin"], # Bottom-right
bbox_home_locations["xmax"], bbox_home_locations["ymax"], # Top-right
bbox_home_locations["xmin"], bbox_home_locations["ymax"], # Top-left
bbox_home_locations["xmin"], bbox_home_locations["ymin"] # Close the polygon
),
ncol = 2, byrow = TRUE
)
bbox_home_locations_polygon <- st_polygon(list(bbox_home_locations_coords))
home_locations_wkt <- st_as_text(bbox_home_locations_polygon) |>
glue_sql()
}
where_home_locations <- glue_sql("ST_WITHIN(ST_GEOGPOINT(lng, lat), ST_GEOGFROMTEXT('{home_locations_wkt}'))",
.con = DBI::ANSI()
)
} else if (length(destinations) == 0 & length(home_locations) == 0) {
print("No destinations or home location boundaries provided. Please provide a way to return trip table.")
stop()
} else {
print("No home locations provided. Using destinations only to determine trips.")
where_home_locations <- glue_sql("", .con = DBI::ANSI())
}
if (length(home_locations_tag) > 0 & length(home_locations_tag_field) > 0) {
home_locations_tag_sf <- arc.open(home_locations_tag) |>
arc.select() |>
arc.data2sf() |>
st_transform(4269) |>
st_make_valid() |>
select(any_of(home_locations_tag_field)) |>
suppressMessages()
print(paste0("Will assign home locations the following tag: ", home_locations_tag_field))
} else {
print("No home location tags provided. Will not append a home location flag to table.")
}
print("Getting megaregion from destination boundary")
# Megaregion mapping
megaregions <- data.frame(
Megaregion = c(
"alaska", "cal_nev", "cal_nev", "great_lakes", "great_lakes",
"great_lakes", "great_lakes", "great_lakes", "great_lakes",
"hawaii", "mid_atlantic", "mid_atlantic", "mid_atlantic",
"mid_atlantic", "mid_atlantic", "north_atlantic", "north_atlantic",
"north_atlantic", "north_atlantic", "north_atlantic", "north_central",
"north_central", "north_central", "north_central", "north_central",
"north_central", "north_central", "northeast", "northeast",
"northeast", "northeast", "northeast", "northwest", "northwest",
"northwest", "northwest", "northwest", "south_atlantic",
"south_atlantic", "south_atlantic", "south_central", "south_central",
"south_central", "south_central", "south_central", "southwest",
"southwest", "southwest", "southwest", "southwest", "southwest"
),
STUSPS = c(
"AK", "CA", "NV", "IL", "IN", "KY", "MI", "OH", "WI", "HI", "DC",
"MD", "NC", "VA", "WV", "CT", "DE", "NJ", "NY", "PA", "IA", "KS",
"MN", "MO", "ND", "NE", "SD", "MA", "ME", "NH", "RI", "VT", "ID",
"MT", "OR", "WA", "WY", "FL", "GA", "SC", "AL", "AR", "LA", "MS",
"TN", "AZ", "CO", "NM", "OK", "TX", "UT"
)
)
if (length(destinations) == 0) {
sf_megaregions <= home_locations_sf
} else {
sf_megaregions <- destinations_sf
}
megaregion <- left_join(tigris::states(cb = TRUE, year = 2023, progress_bar = FALSE), megaregions) |>
st_intersection(sf_megaregions) |>
st_drop_geometry() |>
slice(1L) |>
pull(Megaregion) |>
glue_sql() |>
suppressMessages() |>
suppressWarnings()
# Get SQL arguments for query ---------------------------------------------
# Construct the SQL query
print(paste0("Constructing SQL query for ", megaregion, ", ", year, " ", quarter, " ", day, "..."))
year_sql <- glue_sql(year)
quarter_sql <- glue_sql(quarter)
day_sql <- glue_sql(day)
sql <- glue_sql("
SELECT pop.person_id, activity_id, distance_miles, mode, travel_purpose, pop.commute_mode, pop.household_size, pop.vehicles, pop.age_group, pop.sex, pop.race, pop.ethnicity, pop.employment, pop.education, start_lat, start_lng, end_lat, end_lng, pop.lat as home_lat, pop.lng as home_lng
FROM `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_{day_sql}_trip` as trip
LEFT JOIN `replica-customer.{megaregion}.{megaregion}_{year_sql}_{quarter_sql}_population` as pop
ON trip.person_id = pop.person_id
{where_destinations}
{both_and} {where_home_locations}",
.con = DBI::ANSI()
)
print("Executing SQL query...")
print(sql)
